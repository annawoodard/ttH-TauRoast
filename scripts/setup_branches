#!/usr/bin/env python

from collections import namedtuple
import glob
import os
import re
import ROOT as r
import sys

r.gROOT.SetBatch()

# class used to store accessor information
Attr = namedtuple('Attr', ['name', 'type', 'pointer', 'prefixes'])

def gather_function_info(filename):
    """Returns a list of function names starting with `Get` from a header
    file."""
    names = []
    with open(filename) as f:
        for l in f.readlines():
            m = re.match(r'\s*(?:\w+\s+)*(Get\w*)\(.*', l)
            if m:
                names.append(m.group(1))
    return names

def gather_type_info(filename):
    """Returns a list containing prefix, name, class, and bool indicating
    a pointer."""
    results = []

    f = r.TFile(filename)
    tpl = f.Get("TTbarHTauTau")

    for bn in tpl.GetListOfBranches():
        name = bn.GetName()
        cls = bn.GetClassName()
        ptr = False

        (start, end) = name.split("_", 1)

        if cls.startswith("vector"):
            cls = cls.replace("vector", "std::vector") + "*"
            ptr = True
        elif cls == "":
            cls = tpl.GetLeaf(name).GetTypeName()

        results.append((start, end, cls, ptr))
    return results

def generate_accessor_info(vars):
    attrs = {}
    for (c, n, t, p) in vars:
        # capitalize first letter
        name = n[0].upper() + n[1:]

        # skip single tau info for now
        # FIXME including this yields a conflict with TLL
        if c == 'T':
            continue

        # TTL, TLL, and event variables are not prefixed
        if c not in channels and c != 'Ev':
            name = c + '_' + name

        # lepton1 => L1, tau1 => t1, etc...
        if c in channels:
            m = re.match('(?:(?:Lepton|Tau)\d?)+', name)

            if m:
                full_pre = m.group(0)
                pre = ""
                for (particle, num) in re.findall('(Lepton|Tau)(\d)?', full_pre):
                    pre += particle[0]
                    if num:
                        pre += num

                name = name.replace(m.group(0), pre + '_')

        if name in attrs:
            if c in attrs[name].prefixes:
                continue
            attrs[name].prefixes.append(c)
        else:
            attrs[name] = Attr(n, t, p, [c])
    return attrs

def generate_type_info(channel, vars, common_vars, indent=16):
    """Generates definition, address setting, clearing, and deleting info for
    variables for a given channel, and updates corresponding files."""
    address_lines = []
    clear_lines = []
    declare_lines = []
    delete_lines = []
    null_lines = []

    for (c, n, t, p) in vars:
        if not channel and c in channels and n in common_vars:
            varname = n
            declare_lines.append(' ' * indent + t + ' ' + varname + ';\n')
        elif not (channel and n in common_vars):
            varname = "_".join([c, n])
            declare_lines.append(' ' * indent + t + ' ' + varname + ';\n')
        else:
            varname = n

        if not (not channel and c in channels and n in common_vars):
            address_lines.append("    fChain->SetBranchAddress(\"{0}\", &{1});\n".format("_".join([c, n]), varname))
        if channel and c in channels and n in common_vars:
            continue

        if p:
            clear_lines.append("    {0}->clear();\n".format(varname))
            delete_lines.append("    delete {0};\n".format(varname))
        else:
            clear_lines.append("    {0} = 0;\n".format(varname))

        null_lines.append("    {0} = 0;\n".format(varname))
    if not channel:
        channel = ""
    header = os.path.join(os.environ["LOCALRT"], 'src', 'ttH', 'TauRoast', 'interface', channel + 'Branches.h')
    source = os.path.join(os.environ["LOCALRT"], 'src', 'ttH', 'TauRoast', 'src', channel + 'Branches_generated.cc')
    inject_lines(header, "declarations", declare_lines)
    inject_lines(source, "address", address_lines)
    inject_lines(source, "clear", clear_lines)
    inject_lines(source, "delete", delete_lines)
    inject_lines(source, "null", null_lines)

def inject_lines(filename, key, lines):
    """Replaces the lines between '// >>> Begin <key> <<<' and
    '// >>> End <key> <<<' with the lines supplied."""
    with open(filename) as file:
        old_lines = file.readlines()
    start = filter(lambda (n, s): "// >>> Begin " + key + " <<<" in s,
            enumerate(old_lines))[0][0]
    end = filter(lambda (n, s): "// >>> End " + key + " <<<" in s,
            enumerate(old_lines))[0][0]
    head = old_lines[:start + 1]
    tail = old_lines[end:]
    with open(filename, 'w') as file:
        for l in head + lines + tail:
            file.write(l)

#------------------\
# main script part  >--------------------------------------------------
#------------------/

channels = set(["TTL", "TLL"])

# extract type information from ROOT files passed as arguments, only
# process each unique branch name once
type_info = []
var_names = set()
for fn in sys.argv[1:]:
    for tpl in gather_type_info(fn):
        varname = tpl[0] + '_' + tpl[1]
        if varname in var_names:
            continue
        var_names.add(varname)
        type_info.append(tpl)

vars = sorted(type_info, key=lambda tpl: "_".join(tpl[:2]))

# variables with different branch names in the channels, but same
channel_vars = [set([tpl[1] for tpl in vars if tpl[0] == c]) for c in channels]
common_vars = reduce(lambda a, b: a & b, channel_vars[1:], channel_vars[0])

shared_var_names = set()
shared_vars = []
tmp_vars = filter(lambda (c, n, t, p): c not in channels or n in common_vars, vars)
for tpl in tmp_vars:
    if tpl[0] in channels and tpl[1] in common_vars:
        varname = tpl[1]
    else:
        varname = tpl[0] + '_' + tpl[1]

    if varname in shared_var_names:
        continue
    shared_var_names.add(varname)
    shared_vars.append(tpl)

generate_type_info(None, shared_vars, common_vars, 12)

for channel in channels:
    channel_vars = filter(lambda (k, s, t, p): k == channel, vars)
    print "{0} variables for {1}".format(len(channel_vars), channel)
    if len(channel_vars) > 0:
        generate_type_info(channel, channel_vars, common_vars)

#----------------\
# accessor setup  >----------------------------------------------------
#----------------/

indent = ' ' * 4
lines = []

cast = '{0}::Branches* e = dynamic_cast<{0}::Branches*>(b)'
declare = 'accessors["{0}"] = [](Branches *b, int idx, int n) -> float {{\n'
reindex = 'int i = (*b->CleanJetIndices)[idx][{0}];\n'
returns = {0: 'return {0}->{1};', 1: 'return (*{0}->{1})[{2}];'}

fct_names = {}
for channel in list(channels) + [""]:
    for fn in gather_function_info(os.path.join(os.environ["LOCALRT"],
            'src', 'ttH', 'TauRoast','interface', channel + 'Branches.h')):
        if fn not in fct_names:
            fct_names[fn] = []
        fct_names[fn].append(channel)

for ignore in "GetBestCombo GetEntries GetEntry GetNumCombos".split():
    if ignore in fct_names:
        del fct_names[ignore]

for fn in sorted(fct_names.keys()):
    name = fn.replace("Get", "")
    m = re.match('(?:(?:Lepton|Tau)\d?)+', name)
    if m:
        combo_var = True

        full_pre = m.group(0)
        pre = ""
        for (particle, num) in re.findall('(Lepton|Tau)(\d)?', full_pre):
            pre += particle[0]
            if num:
                pre += num

        name = name.replace(m.group(0), pre + '_')

    m = re.match('((?:Clean)?)Jet', name)
    if m:
        combo_var = False
        name = name.replace(m.group(0), m.group(1) + 'J_')

    lines.append(indent * 2 + declare.format(name))
    if len(fct_names[fn]) == 1:
        channel = fct_names[fn][0]
        var = 'b'
        if channel != "":
            var = 'e'
            lines.append(indent * 3 + cast.format(channel.lower()) + ';\n')
        if combo_var:
            lines.append(indent * 3 + 'return {0}->{1}(idx);\n'.format(var, fn))
        else:
            lines.append(indent * 3 + 'return {0}->{1}(idx, n);\n'.format(var, fn))
        lines.append(indent * 2 + '};\n')
    else:
        # FIXME not yet implemented
        raise NotImplementedError

attrs = generate_accessor_info(vars)

def generate_return_line(obj, varname, type, idx='idx', safe=False):
    cnt = type.count('vector')
    if cnt not in returns:
        raise TypeError
    if safe:
        return returns[cnt].replace("[{2}]", ".at({2})").format(obj, varname, idx)
    else:
        return returns[cnt].format(obj, varname, idx)

jets = 'LJ SubLJ SubSubLJ SubSubSubLJ'.split()

for k in sorted(attrs.keys()):
    (var, type, ptr, prefixes) = attrs[k]

    # manipulate variable names to get "historic" naming scheme
    # FIXME rename branches in ntuplizer

    # no mention of HPS anywhere
    rm = re.search(r'HPS(?:by)?(.)', k)
    if rm:
        k = k.replace(rm.group(0), rm.group(1).upper())
        k = k.replace("Against", "Anti")

    # N -> Num where appropriate
    num = re.search(r'_N([A-Z][a-z])', k)
    if num:
        k = k.replace(num.group(0), '_Num' + num.group(1))

    # remove btagJets at end of varname
    if k.endswith('btagJets'):
        k = 'J_' + k[:-8]

    # camel case correctly
    k = k.replace("raw", "Raw")

    try:
        tmp_lines = []
        tmp_lines.append(indent * 2 + declare.format(k))

        if len(prefixes) == 1 or var in common_vars:
            if prefixes[0] in channels and var in common_vars:
                prefix = ""
                varname = var
            else:
                prefix = prefixes[0]
                varname = prefix + '_' + var
            obj = 'b'

            idx = 'idx' if prefixes[0] in channels else 'n'

            if prefix in channels:
                chan = prefix.lower()
                varname = prefix + "_" + var
                obj = 'e'
                tmp_lines.append(indent * 3 + cast.format(chan) + ';\n')
            elif prefix == 'J' and ptr and not 'BTag' in var:
                jet_lines = []

                jet_lines.append(indent * 2 + declare.format('Clean' + k))
                jet_lines.append(indent * 3 + reindex.format('n'))
                jet_lines.append(indent * 3 + generate_return_line(obj, varname, type, idx='i', safe=True) + '\n')
                jet_lines.append(indent * 2 + '};\n')

                # leading jet etc.
                for (n, j) in enumerate(jets):
                    new_key = k.replace('J', j)
                    jet_lines.append(indent * 2 + declare.format(new_key))
                    jet_lines.append(indent * 3 + reindex.format(n))
                    jet_lines.append(indent * 3 + generate_return_line(obj, varname, type, idx='i', safe=True) + '\n')
                    jet_lines.append(indent * 2 + '};\n')
                lines += jet_lines
            elif ptr and prefix != '':
                continue
            tmp_lines.append(indent * 3 + generate_return_line(obj, varname, type) + '\n')
        else:
            cond = 'if ('
            first = True

            for p in prefixes:
                if p not in channels:
                    raise ValueError(p)

                chan = p.lower()
                if var not in shared_var_names:
                    varname = p + "_" + var
                else:
                    varname = var
                tmp_lines.append(indent * 3 + cond + cast.format(chan) + ') {\n')
                tmp_lines.append(indent * 4 + generate_return_line('e', varname, type) + '\n')

                if first:
                    first = False
                    cond = '} else ' + cond
            tmp_lines.append(indent * 3 + '}\n')
            tmp_lines.append(indent * 3 + 'throw "";\n')
            # tmp_lines.append(indent * 3 + 'return -1. / 0.;\n')
        tmp_lines.append(indent * 2 + '};\n')

        lines += tmp_lines
    except ValueError as e:
        print '{0} is not a valid channel'.format(e)
    except TypeError as e:
        print '{0} is of unprocessable type'.format(k)

source = os.path.join(os.environ["LOCALRT"], 'src', 'ttH', 'TauRoast', 'src', 'Accessor.cc')
inject_lines(source, "attr", lines)
