#!/usr/bin/env python

from collections import namedtuple
import glob
import os
import re
import ROOT as r
import sys

r.gROOT.SetBatch()

# class used to store accessor information
Attr = namedtuple('Attr', ['prefix', 'name', 'channels'])

def gather_function_info(filename):
    """Returns a list of function names starting with `Get` from a header
    file."""
    names = []
    with open(filename) as f:
        for l in f.readlines():
            m = re.match(r'\s*(?:\w+\s+)*(Get\w*)\(.*', l)
            if m:
                names.append(m.group(1))
    return names

def gather_type_info(filename, channel):
    """Returns a list containing channel, prefix, name, class, and bool
    indicating a pointer."""
    results = []

    f = r.TFile(filename)
    tpl = f.Get("TTbarHTauTau")

    for bn in tpl.GetListOfBranches():
        name = bn.GetName()
        cls = bn.GetClassName()
        ptr = False

        (start, end) = name.split("_", 1)

        if cls.startswith("vector"):
            cls = cls.replace("vector", "std::vector") + "*"
            ptr = True
        elif cls == "":
            cls = tpl.GetLeaf(name).GetTypeName()

        results.append((channel, start, end, cls, ptr))
    return results

def generate_accessor_info(vars, common_vars):
    attrs = {}
    for (chan, pre, stem, type, ptr) in vars:
        # capitalize first letter
        name = stem[0].upper() + stem[1:]

        # skip single tau info for now
        # FIXME including this yields a conflict with TLL
        if pre == 'T':
            continue

        # TTL, TLL, and event variables are not prefixed
        if pre not in channels and pre != 'Ev':
            name = pre + '_' + name

        # lepton1 => L1, tau1 => t1, etc...
        if c in channels:
            m = re.match('(?:(?:Lepton|Tau)\d?)+', name)

            if m:
                full_lep = m.group(0)
                lep = ""
                for (particle, num) in re.findall('(Lepton|Tau)(\d)?', full_lep):
                    lep += particle[0]
                    if num:
                        lep += num

                name = name.replace(m.group(0), lep + '_')

        if stem in common_vars:
            varname = stem
        else:
            varname = pre + '_' + stem

        if name in attrs:
            if chan in attrs[name].channels:
                continue
            attrs[name].channels[chan] = (varname, type, ptr)
        else:
            attrs[name] = Attr(pre, stem, {chan: (varname, type, ptr)})
    return attrs

def generate_type_info(channel, vars, common_vars, indent=16):
    """Generates definition, address setting, clearing, and deleting info for
    variables for a given channel, and updates corresponding files."""
    address_lines = []
    clear_lines = []
    declare_lines = []
    delete_lines = []
    null_lines = []

    for (c, n, t, p) in vars:
        if not channel and c in channels and n in common_vars:
            varname = n
            declare_lines.append(' ' * indent + t + ' ' + varname + ';\n')
        elif not (channel and n in common_vars):
            varname = "_".join([c, n])
            declare_lines.append(' ' * indent + t + ' ' + varname + ';\n')
        elif c == 'J':
            varname = "_".join([c, n])
        else:
            varname = n

        if not (not channel and c in channels and n in common_vars):
            address_lines.append("    fChain->SetBranchAddress(\"{0}\", &{1});\n".format("_".join([c, n]), varname))
        if channel and c in channels and n in common_vars:
            continue

        if p:
            clear_lines.append("    {0}->clear();\n".format(varname))
            delete_lines.append("    delete {0};\n".format(varname))
        else:
            clear_lines.append("    {0} = 0;\n".format(varname))

        null_lines.append("    {0} = 0;\n".format(varname))
    if not channel:
        channel = ""
    header = os.path.join(os.environ["LOCALRT"], 'src', 'ttH', 'TauRoast', 'interface', channel + 'Branches.h')
    source = os.path.join(os.environ["LOCALRT"], 'src', 'ttH', 'TauRoast', 'src', channel + 'Branches_generated.cc')
    inject_lines(header, "declarations", declare_lines)
    inject_lines(source, "address", address_lines)
    inject_lines(source, "clear", clear_lines)
    inject_lines(source, "delete", delete_lines)
    inject_lines(source, "null", null_lines)

def inject_lines(filename, key, lines):
    """Replaces the lines between '// >>> Begin <key> <<<' and
    '// >>> End <key> <<<' with the lines supplied."""
    with open(filename) as file:
        old_lines = file.readlines()
    start = filter(lambda (n, s): "// >>> Begin " + key + " <<<" in s,
            enumerate(old_lines))[0][0]
    end = filter(lambda (n, s): "// >>> End " + key + " <<<" in s,
            enumerate(old_lines))[0][0]
    head = old_lines[:start + 1]
    tail = old_lines[end:]
    with open(filename, 'w') as file:
        for l in head + lines + tail:
            file.write(l)

#------------------\
# main script part  >--------------------------------------------------
#------------------/

channels = set(["TTL", "TLL", "TL", "LL"])

# extract type information from ROOT files passed as arguments, only
# process each unique branch name once
type_info = []
for fn in sys.argv[1:]:
    file_channels = filter(lambda c: '/' + c.lower() + '_' in fn, channels)
    if len(file_channels) != 1:
        sys.stderr.write("unable to determine channel of file '{0}'\n".format(fn))
        raise KeyError

    for tpl in gather_type_info(fn, file_channels[0]):
        type_info.append(tpl)

vars = sorted(type_info, key=lambda tpl: "_".join(tpl[1:3]))

single_var_names = {}
for (chan, pre, name, type, ptr) in vars:
    if pre in channels:
        continue
    try:
        var = pre + '_' + name
        single_var_names[var].append(chan)
        if len(single_var_names[var]) == len(channels):
            del single_var_names[var]
    except KeyError:
        single_var_names[var] = [chan]

for (k, v) in list(single_var_names.items()):
    if len(v) == len(channels):
        del single_var_names[k]

# Variables with different branch names in the channels, but same variable
# name stem.
channel_var_info = [set([tpl[2:] for tpl in vars if tpl[1] == c]) for c in channels]
common_var_info = reduce(lambda a, b: a & b, channel_var_info[1:], channel_var_info[0])
common_vars = [tpl[0] for tpl in common_var_info]

# Variables shared between the different channels.  This includes the common
# variables.
shared_var_names = set()
shared_vars = []
tmp_vars = filter(lambda (chan, pre, name, type, ptr): pre not in channels or name in common_vars, vars)
for (chan, pre, name, type, ptr) in tmp_vars:
    if pre in channels and name in common_vars:
        varname = name
    else:
        varname = pre + '_' + name

    if varname in shared_var_names or varname in single_var_names:
        continue
    shared_var_names.add(varname)
    shared_vars.append((pre, name, type, ptr))

generate_type_info(None, shared_vars, common_vars, 12)

for channel in channels:
    unique_var_names = [k for (k, v) in single_var_names.items() if channel in v]
    channel_vars = sorted(set([(pre, name, type, ptr) for (chan, pre, name, type, ptr) in vars if chan == channel and (pre == channel or pre + '_' + name in unique_var_names)]), key=lambda tpl: '_'.join(tpl[:2]))
    print "{0} variables for {1}, unique: {2}".format(len(channel_vars), channel, ", ".join(unique_var_names))
    if len(channel_vars) > 0:
        generate_type_info(channel, channel_vars, common_vars)

#----------------\
# accessor setup  >----------------------------------------------------
#----------------/

indent = ' ' * 4
lines = []

cast = '{0}::Branches* e = dynamic_cast<{0}::Branches*>(b)'
declare = 'accessors["{0}"] = [](Branches *b, int idx, int n) -> float {{\n'
reindex = [
        ('Clean', 'int i = (*b->CleanJetIndices)[idx][{0}];\n'),
        ('Tagged', 'int i = (*b->CleanJetCSVMIndices)[idx][{0}];\n'),
        ('Untagged', 'int i = (*b->CleanJetNonCSVMIndices)[idx].at({0});\n')
        ]
returns = {
        0: 'return {0}->{1};',
        1: 'return (*{0}->{1})[{2}];',
        2: 'return (*{0}->{1})[{2}][{3}];'
        }

accessor_template = \
"""        accessors["{0}"] = [](roast::Branches *b, int idx, int n) -> float {{
            {1}
        }};
"""

cast_template = """if ({0}::Branches* e = dynamic_cast<{0}::Branches*>(b)) {{
                {1}
            }}"""

throw_template = """
            throw;"""

tll_template = \
"""        accessors["{1}"] = [](roast::Branches *b, int idx, int n) -> float {{
            tll::Branches* e = dynamic_cast<tll::Branches*>(b);
            if ((*e->TLL_Lepton1Charge)[idx] * (*e->TLL_TauCharge)[idx] {0} 0) {{
                return (*e->{2})[idx];
            }}
            return (*e->{3})[idx];
        }};
"""

fct_names = {}
for channel in list(channels) + [""]:
    for fn in gather_function_info(os.path.join(os.environ["LOCALRT"],
            'src', 'ttH', 'TauRoast','interface', channel + 'Branches.h')):
        if fn not in fct_names:
            fct_names[fn] = []
        fct_names[fn].append(channel)

# Deal with functions first
for ignore in "GetBestCombo GetEntries GetEntry GetNumCombos".split():
    if ignore in fct_names:
        del fct_names[ignore]

for fn in sorted(fct_names.keys()):
    name = fn.replace("Get", "")
    m = re.match('(?:(?:Lepton|Tau)\d?)+', name)
    if m:
        combo_var = True

        full_pre = m.group(0)
        pre = ""
        for (particle, num) in re.findall('(Lepton|Tau)(\d)?', full_pre):
            pre += particle[0]
            if num:
                pre += num

        name = name.replace(m.group(0), pre + '_')

    m = re.match('((?:Clean)?)Jet', name)
    if m:
        combo_var = False
        name = name.replace(m.group(0), m.group(1) + 'J_')

    lines.append(indent * 2 + declare.format(name))
    if len(fct_names[fn]) == 1:
        channel = fct_names[fn][0]
        var = 'b'
        if channel != "":
            var = 'e'
            lines.append(indent * 3 + cast.format(channel.lower()) + ';\n')
        if combo_var:
            lines.append(indent * 3 + 'return {0}->{1}(idx);\n'.format(var, fn))
        else:
            lines.append(indent * 3 + 'return {0}->{1}(idx, n);\n'.format(var, fn))
        lines.append(indent * 2 + '};\n')
    else:
        cond = 'if ('

        for p in fct_names[fn]:
            if p not in channels:
                raise ValueError(p)

            chan = p.lower()
            if var not in shared_var_names:
                varname = p + "_" + var
            else:
                varname = var
            lines.append(indent * 3 + cond + cast.format(chan) + ') {\n')
            if combo_var:
                lines.append(indent * 4 + 'return {0}->{1}(idx);\n'.format(var, fn))
            else:
                lines.append(indent * 4 + 'return {0}->{1}(idx, n);\n'.format(var, fn))

            cond = '} else if ('
        lines.append(indent * 3 + '}\n')
        lines.append(indent * 3 + 'throw "";\n')
        # lines.append(indent * 3 + 'return -1. / 0.;\n')
        lines.append(indent * 2 + '};\n')

attrs = generate_accessor_info(vars, common_vars)

# Now turn to branches
def generate_return_line(obj, typeinfo, reindex=False, safe=False):
    types = set(typeinfo.values())
    idx = 'idx'
    subidx = 'n'
    if len(types) == 1 and len(typeinfo.keys()) == len(channels):
        (varname, type, ptr) = list(types)[0]
        cnt = type.count('vector')

        if cnt not in returns:
            raise TypeError

        if reindex:
            if cnt == 1:
                idx = 'i'
            elif cnt == 2:
                subidx = 'i'

        if safe:
            return returns[cnt].replace("[{2}]", ".at({2})").replace("[{3}]", ".at({3})").format('b', varname, idx, subidx)
        return returns[cnt].format('b', varname, idx, subidx)
    else:
        lines = []
        for (chan, (varname, type, ptr)) in typeinfo.items():
            cnt = type.count('vector')
            ret_line = returns[cnt]

            parts = varname.split('_', 1)
            if parts[0] in channels:
                varname = chan + '_' + parts[1]

            nidx = idx
            nsubidx = subidx
            if reindex:
                if cnt == 1:
                    nidx = 'i'
                elif cnt == 2:
                    nsubidx = 'i'

            if safe:
                ret_line = ret_line.replace("[{2}]", ".at({2})").replace("[{3}]", ".at({3})")
            lines.append(cast_template.format(chan.lower(), ret_line.format('e', varname, nidx, nsubidx)))
        return " else ".join(lines) + throw_template

jets = 'LJ SubLJ SubSubLJ SubSubSubLJ'.split()

for accessor in sorted(attrs.keys()):
    (pre, var, chans) = attrs[accessor]

    # consolidate type information
    types = set([type for (varname, type, ptr) in chans.values()])
    if len(types) == 1 and 'LorentzVector' in list(types)[0]:
        # cannot do anything with a LorentzVector at the moment
        continue

    # manipulate variable names to get "historic" naming scheme
    # FIXME rename branches in ntuplizer

    # no mention of HPS anywhere
    rm = re.search(r'HPS(?:by)?(.)', accessor)
    if rm:
        accessor = accessor.replace(rm.group(0), rm.group(1).upper())
        accessor = accessor.replace("Against", "Anti")

    # N -> Num where appropriate
    num = re.search(r'_N([A-Z][a-z])', accessor)
    if num:
        accessor = accessor.replace(num.group(0), '_Num' + num.group(1))

    # remove btagJets at end of varname
    if accessor.endswith('btagJets'):
        accessor = 'J_' + accessor[:-8]

    # camel case correctly
    accessor = accessor.replace("raw", "Raw")

    # convert convention for jet variables
    if pre == 'J':
        for (particle, count) in re.findall('(Tau|Lepton)(\d)?', accessor):
            accessor = accessor.replace('_', particle[0] + count + '_', 1).replace(particle + count, '', 1)

    try:
        tmp_lines = []

        # For OS TLL, we can fix the tau + tau->lepton system
        if 'TLL' in chans:
            varname = chans['TLL'][0]
            if chans['TLL'][1].count('vector') == 1 \
                    and 'Lepton1' in varname and 'Lepton2' not in varname:
                lines += tll_template.format("<", accessor.replace('L1', 'osL'), varname, varname.replace('Lepton1', 'Lepton2'))
                lines += tll_template.format(">", accessor.replace('L1', 'ssL'), varname, varname.replace('Lepton1', 'Lepton2'))

        if pre != 'J':
            tmp_lines.append(indent * 2 + declare.format(accessor))
            if pre not in channels and pre != 'Ev':
                if 'Num' not in accessor:
                    continue
            print accessor
            tmp_lines.append(indent * 3 + generate_return_line('b', chans) + '\n')
        else:
            if var == 'combSecVtxBTag':
                accessor = accessor.replace('CombSecVtxBTag', 'CSV')
            elif var == 'CSV' or 'BTag' in var or var == 'MomentumRank':
                continue

            jet_lines = []

            tmp_lines.append(indent * 2 + declare.format(accessor))
            tmp_lines.append(indent * 3 + generate_return_line('b', chans) + '\n')

            if 'Num' not in var:
                for (label, index_statement) in reindex:
                    jet_lines.append(indent * 2 + declare.format(label + accessor))
                    jet_lines.append(indent * 3 + index_statement.format('n'))
                    jet_lines.append(indent * 3 + generate_return_line('b', chans, reindex=True, safe=True) + '\n')
                    jet_lines.append(indent * 2 + '};\n')

                    # leading jet etc.
                    for (n, j) in enumerate(jets):
                        new_key = label + accessor.replace('J', j)
                        jet_lines.append(indent * 2 + declare.format(new_key))
                        jet_lines.append(indent * 3 + index_statement.format(n))
                        jet_lines.append(indent * 3 + generate_return_line('b', chans, reindex=True, safe=True) + '\n')
                        jet_lines.append(indent * 2 + '};\n')
                lines += jet_lines

        tmp_lines.append(indent * 2 + '};\n')

        lines += tmp_lines
    except ValueError as e:
        print 'cannot associate {0} with a valid channel: {1}'.format(accessor, e)
    except TypeError as e:
        print '{0} is of unprocessable type'.format(accessor)

source = os.path.join(os.environ["LOCALRT"], 'src', 'ttH', 'TauRoast', 'src', 'Accessor.cc')
inject_lines(source, "attr", lines)
