#!/usr/bin/env python
# vim: ts=4:sw=4:et:sta

import argparse
import codecs
import logging
import os
import pickle
import yaml

parser = argparse.ArgumentParser(description='Grill some taus.')
parser.add_argument('config', metavar='config', type=str, nargs=1,
        help='a configuration file to use')
parser.add_argument('-v', '--verbose', action="count", default=0,
        help="increase verbosity")
parser.add_argument('-q', '--quiet', action="count", default=0,
        help="decrease verbosity")
ag = parser.add_argument_group('analysis options')
ag.add_argument('-a', '--analyze', action='store_true', default=False,
        help="analyze datasets")
ag.add_argument('-f', '--fill', action='store_true', default=False,
        help="fill histograms")
ag.add_argument('-p', '--plot', action='store_true', default=False,
        help="save histograms")
ag.add_argument('-t', '--train', action='store_true', default=False,
        help="train MVAs")
ag = parser.add_argument_group('general options')
ag.add_argument('-i', '--input', type=str, default=None,
        help="change input directory")
ag.add_argument('-o', '--output', type=str, default=None,
        help="change output directory")
ag = parser.add_argument_group('debugging and syncronization options')
ag.add_argument('--debug-cuts', action='store_true', default=False,
        help="save event quantites after each cut")

args = parser.parse_args()

if not any([args.analyze, args.fill, args.plot, args.train]):
    parser.error("need to either analyze, fill, plot, or train")

# Logging setup
logging.basicConfig(
        datefmt="%Y-%m-%d %H:%M:%S",
        format="%(asctime)s [%(levelname)s] - %(filename)s %(lineno)d: %(message)s")

logging.__dict__['root'].level = (2 + args.quiet - args.verbose) * 10

with open(args.config[0]) as f:
    config = yaml.load(f)

if args.output:
    config['outdir'] = args.output
if args.input:
    config['indir'] = args.input

for k in ('outdir', 'ntupledir'):
    config[k] = os.path.expanduser(os.path.expandvars(config[k]))

datadir = os.path.join(os.environ["LOCALRT"], 'src', 'ttH', 'TauRoast', 'data')

with open(os.path.join(datadir, 'plot.yaml')) as f:
    plotconfig = yaml.load(f)

import ROOT as r

r.gROOT.SetBatch()
r.gErrorIgnoreLevel = 1001

if r.gROOT.GetVersion().startswith('6'):
    header = os.path.join(os.environ["LOCALRT"], 'src', 'ttH', 'TauRoast', 'interface', 'SuperSlim.h')
    r.gInterpreter.ProcessLine('#include "{0}"'.format(header))

r.gSystem.Load("libttHTauRoast")

from ttH.TauRoast import stylish, useful
from ttH.TauRoast.botany import Forest
from ttH.TauRoast.cutting import StaticCut, Cut, cutflow, normalize
from ttH.TauRoast.plotting import Plot
from ttH.TauRoast.processing import Process
from ttH.TauRoast.printable import SyncSaver
from ttH.TauRoast.variation import setup, train

useful.channel(config['channel'])
stylish.setup()

import imp
from glob import glob
magic = os.path.join(datadir, 'plots', '*.py')
for n, file in enumerate(glob(magic)):
    imp.load_source("plots{0}".format(n), file)

magic = os.path.join(datadir, 'procs', '*.py')
for n, file in enumerate(glob(magic)):
    imp.load_source("procs{0}".format(n), file)

if 'mva' in config:
    cfg = config['mva']
    setup(config['outdir'], cfg['variables'])

if args.analyze:
    counts = []
    cuts = [
            Cut("Ntuple analyzed", "True")
    ]
    weights = []

    for hash in config["cuts"]:
        cuts.append(Cut(*hash.items()[0]))

    for weight in config["weights"]:
        weights.append(StaticCut(weight))

    if not os.path.exists(config["outdir"]):
        os.makedirs(config["outdir"])

    fn = os.path.join(config["outdir"], "ntuple.root")
    if os.path.exists(fn):
        os.unlink(fn)

    processed = set()
    for proc in sum(map(Process.expand, config['plot']), []):
        if proc in processed:
            continue
        processed.add(proc)
        local_cuts = list(cuts)
        for cfg in proc.additional_cuts:
            local_cuts.insert(0, Cut(*cfg))

        callbacks = None
        if args.debug_cuts:
            callbacks = []
            for i in range(len(local_cuts)):
                callbacks.append(SyncSaver(config["channel"], os.path.join(config["outdir"], "cut_{0}.txt".format(i))))

        proc.analyze(fn, counts, local_cuts, weights, config["systematics"], config['ntupledir'], callbacks=callbacks)

    cuts = counts + cuts + weights
    normalize(cuts, config["lumi"])
    try:
        cutflow(cuts, config["plot"])
    except UnicodeEncodeError:
        pass

    with codecs.open(os.path.join(config["outdir"], "cuts.txt"), "w", encoding="utf8") as fd:
        cutflow(cuts, config["plot"], f=fd)
    with codecs.open(os.path.join(config["outdir"], "cuts_rel.txt"), "w", encoding="utf8") as fd:
        cutflow(cuts, config["plot"], f=fd, relative=True)

    fn = os.path.join(config["outdir"], "cutflow.pkl")
    with open(fn, 'wb') as f:
        pickle.dump(cuts, f)
elif args.fill:
    fn = os.path.join(config.get("indir", config["outdir"]), "cutflow.pkl")
    with open(fn, 'rb') as f:
        cuts = pickle.load(f)[:-1]
    normalize(cuts, config["lumi"])
    try:
        cutflow(cuts, config["plot"])
    except UnicodeEncodeError:
        pass

if args.train:
    fn = os.path.join(config["outdir"], "ntuple.root")
    ofn = os.path.join(config["outdir"], "tmva.root")
    cfg = config['mva']
    train(fn, cfg['signals'], cfg['backgrounds'], cfg['variables'], ofn)

if args.fill:
    fn = os.path.join(config.get("indir", config["outdir"]), "ntuple.root")
    forest = Forest(fn)
    processed = set()
    for proc in sum(map(Process.expand, config['plot']), []):
        if proc in processed:
            continue
        processed.add(proc)
        for p in Plot.plots():
            p.fill(proc, config["weights"])

    fn = os.path.join(config["outdir"], "plots.root")
    f = r.TFile(fn, "RECREATE")

    if not f.IsOpen():
        raise IOError("Can't read file '{0}'".format(fn))

    for p in Plot.plots():
        p.write(f, cuts, fmt=config["histformat"])

    fn = os.path.join(config["outdir"], "limits.root")
    f = r.TFile(fn, "RECREATE")

    if not f.IsOpen():
        raise IOError("Can't read file '{0}'".format(fn))

    for p in Plot.plots():
        p.write(f, cuts, procs=config["limits"], fmt=config["histformat"])

    timing = sorted(Plot.plots(), key=lambda p: p._time)
    for p in timing[:10] + timing[-10:]:
        logging.debug("plot filling time for {0}: {1}".format(p, p._time))

    f.Write()
    f.Close()

    del forest
elif args.plot:
    processes = sum(map(Process.expand, config['plot']), [])
    fn = os.path.join(config.get("indir", config["outdir"]), "plots.root")
    f = r.TFile(fn, "READ")

    if not f.IsOpen():
        raise IOError("Can't read file '{0}'".format(fn))

    for p in Plot.plots():
        p.read(f, processes, fmt=config["histformat"])

    f.Close()

if args.plot:
    for p in Plot.plots():
        p.save(plotconfig, config["outdir"])
