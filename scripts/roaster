#!/usr/bin/env python
# vim: ts=4:sw=4:et:sta

import argparse
import codecs
import logging
import os
import yaml

parser = argparse.ArgumentParser(description='Grill some taus.')
parser.add_argument('config', metavar='config', type=str, nargs=1,
        help='a configuration file to use')
parser.add_argument('-v', '--verbose', action="count", default=0,
        help="increase verbosity")
parser.add_argument('-q', '--quiet', action="count", default=0,
        help="decrease verbosity")
ag = parser.add_argument_group('analysis options')
ag.add_argument('-f', '--fill', action='store_true', default=False,
        help="fill histograms")
ag.add_argument('-p', '--plot', action='store_true', default=False,
        help="save histograms")

args = parser.parse_args()

if not any([args.fill, args.plot]):
    parser.error("need to either fill or plot")

# Logging setup
logging.basicConfig(
        datefmt="%Y-%m-%d %H:%M:%S",
        format="%(asctime)s [%(levelname)s] - %(filename)s %(lineno)d: %(message)s")

logging.__dict__['root'].level = (2 + args.quiet - args.verbose) * 10

with open(args.config[0]) as f:
    config = yaml.load(f)

for k in ('outdir', 'ntupledir'):
    config[k] = os.path.expanduser(os.path.expandvars(config[k]))

datadir = os.path.join(os.environ["LOCALRT"], 'src', 'ttH', 'TauRoast', 'data')

with open(os.path.join(datadir, 'plot.yaml')) as f:
    plotconfig = yaml.load(f)

import ROOT as r

r.gROOT.SetBatch()
r.gErrorIgnoreLevel = 1001

header = os.path.join(os.environ["LOCALRT"], 'src', 'ttH', 'TauRoast', 'interface', 'SuperSlim.h')
r.gInterpreter.ProcessLine('#include "{0}"'.format(header))

r.gSystem.Load("libttHTauRoast")

from ttH.TauRoast import stylish
from ttH.TauRoast.cutting import StaticCut, Cut, cutflow, normalize
from ttH.TauRoast.plotting import Plot
from ttH.TauRoast.processing import Process

stylish.setup()

import imp
from glob import glob
magic = os.path.join(datadir, 'plots', '*.py')
for n, file in enumerate(glob(magic)):
    imp.load_source("plots{0}".format(n), file)

magic = os.path.join(datadir, 'procs', '*.py')
for n, file in enumerate(glob(magic)):
    imp.load_source("procs{0}".format(n), file)

if args.fill:
    counts = []
    cuts = [
            Cut("Ntuple analyzed", "True")
    ]
    weights = []

    for hash in config["cuts"]:
        cuts.append(Cut(*hash.items()[0]))

    for weight in config["weights"]:
        weights.append(StaticCut(weight))

    for proc in sum(map(Process.expand, config['plot']), []):
        local_cuts = list(cuts)
        for cfg in proc.additional_cuts:
            local_cuts.insert(0, Cut(*cfg))
        proc.analyze(counts, local_cuts, weights, Plot.plots(), config['ntupledir'])

    cuts = counts + cuts + weights
    normalize(cuts, config["lumi"])
    cutflow(cuts, config["plot"])

    with codecs.open(os.path.join(config["outdir"], "cuts.txt"), "w", encoding="utf8") as fd:
        cutflow(cuts, config["plot"], f=fd)
    with codecs.open(os.path.join(config["outdir"], "cuts_rel.txt"), "w", encoding="utf8") as fd:
        cutflow(cuts, config["plot"], f=fd, relative=True)

    if not os.path.exists(config["outdir"]):
        os.makedirs(config["outdir"])
    fn = os.path.join(config["outdir"], "plots.root")
    f = r.TFile(fn, "RECREATE")

    if not f.IsOpen():
        raise IOError("Can't read file '{0}'".format(fn))

    for p in Plot.plots():
        p.write(f, cuts, fmt="{p}_{v}_TTL")

    timing = sorted(Plot.plots(), key=lambda p: p._time)
    for p in timing[:10] + timing[-10:]:
        logging.debug("plot filling time for {0}: {1}".format(p, p._time))

    f.Write()
    f.Close()
else:
    processes = sum(map(Process.expand, config['plot']), [])
    fn = os.path.join(config["outdir"], "plots.root")
    f = r.TFile(fn, "READ")

    if not f.IsOpen():
        raise IOError("Can't read file '{0}'".format(fn))

    for p in Plot.plots():
        p.read(f, processes, fmt="{p}_{v}_TTL")

    f.Close()

if args.plot:
    for p in Plot.plots():
        p.save(plotconfig, config["outdir"])
